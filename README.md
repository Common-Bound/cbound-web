# 커먼바운드

## 멤버

- **김은수** - *Server* - [eunsukimme](https://github.com/eunsukimme)
  - 데이터 생산자가 생산한 데이터를 검수하는 과정에서 검수자가 검수 페이지에 접속하면 DB에서 검수 할 데이터를 가져온다. 검수자는 가져온 데이터의 적합/부적합 여부를 판단한 뒤에 이를 다시 DB로 전송하고, DB에 저장된 해당 데이터의 검수 현황 필드를 갱신시킨다. 이 때, 여러 검수자가 동시에 접속하여 동일한 데이터에 대해서 검수를 진행하면, 먼저 검수를 진행한 3명의 검수 결과만 DB에 반영되고 다른 검수자들의 작업은 반영되지 못 하게 된다. 즉, 검수자가 작업을 진행 했음에도 불구하고 기여를 인정받지 못 하게 되는 것이다. 또한 여러 검수자가 동시에 접속하면, 이전 검수자의 히스토리도 확인할 수 없게 된다. 이러한 문제를 해결하기 위해서 작업 큐(Job Queue)를 만들고 검수할 데이터를 큐에 저장하여 먼저 검수 페이지에 접속한 검수자가 특정 데이터를 불러오면, 해당 작업을 큐에서 불러와 스케줄링 상태를 'queued' 에서 'reserved'로 변경하도록 하였다. 그리하여 먼저 접속한 검수자가 검수를 진행하는 동안 다른 검수자는 해당 데이터에 접근하지 못 하도록 하고, 검수 작업이 끝나면 해당 데이터의 검수 현황을 갱신한 후 다시 큐에 넣어 스케줄링 상태를 'reserved'에서 'queued'로 변경시킨다. 그런 뒤 다른 검수자가 검수 페이지에 접속했을 때, 해당 데이터를 불러올 수 있고 이전 검수자의 검수 히스토리를 확인할 수 있게 된다. 
또한 검수 작업을 트랜잭션으로 만들어서, 검수 프로세스가 온전히 완료되어야만 commit 하여 데이터의 검수 현황을 갱신시킬 수 있도록 하였다. 그리하여 만약 검수자가 검수 도중 이탈하게 된다면 rollback 하여 해당 검수 작업은 반영되지 않도록 하였다.
- **최현서** - *Client* - [HyunSeoChoi](https://github.com/HyunSeoChoi)
  - 이미지를 업로드 하고 그 이미지 위에서 영역을 지정(크롭) 할 수 있게끔 만듦.
  - 크롭한 영역들을 리액트 컴포넌트로 관리하여 영역 추가, 삭제, 수정에 용이하게 함.
  - 업로드, 크롭 완료, 서버로 전송 등 이벤트가 발생할 때마다 크롭 리스트들을 패킹하여 서버로 전송함.
  - 캔버스 좌표계와 크롭 영역 좌표계가 달라 실제 비율로 동기화함.
  - 캔버스 좌표계로 변환된 크롭 영역을 캔버스에 모든 크롭 이미지를 그려주는 기능 구현.
- **김광호** - *API* - [FKgk](https://github.com/FKgk)
  - 사용자가 한 이미지를 올릴 때 한번 Detction에, 영역 개수 만큼 Recognition에 요청을 보낸다. 이러다 보니 서버는 동시에 다수의 요청에 대해 각각 병렬적으로 수행해야 한다. 이를 위해 Nginx를 통한 로드밸런싱으로 다수의 요청에 대응할 수 있게 하였다.
Detection와 Recogition를 한 서버에 두니, 많은 GPU Memory 사용량에 의해 Out of Memory 에러가 발생했다. GPU 사용량을 자세히 보니 Detection을 수행할 때는 많은 메모리를 요구하지만, Recognition의 경우 Detection에 비해 적은 메모리만으로도 충분했다. 그래서 Detection와 Recogition의 서버를 분리시켜 Detection은 높은 메모리를 갖는 ec2, Recognition은 빠른 연산을 갖는 ec2에서 동작하도록 했다. 

[contributors](https://github.com/eunsukimme/Common-Bound/contributors) 를 참고해주세요

## 코딩 스타일

[Coding Style](./Coding Style.md)

## 설치 방법

[How to Install](./How to Install.md)